<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/logic_solver.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/logic_solver.py" />
              <option name="originalContent" value="from logic import *&#10;import itertools&#10;from truth_table import TruthTable&#10;from visualizer import Visualizer&#10;&#10;&#10;class LogicPuzzleSolver:&#10;    &quot;&quot;&quot;&#10;    Clase principal para resolver rompecabezas logicos usando&#10;    logica proposicional y tablas de verdad.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.knowledge_base = None&#10;        self.symbols_dict = {}&#10;        self.premises = []&#10;        self.queries = []&#10;&#10;    def solve_puzzle(self, puzzle_data):&#10;        &quot;&quot;&quot;&#10;        Resuelve un rompecabezas logico completo.&#10;&#10;        Args:&#10;            puzzle_data: Diccionario con la estructura del rompecabezas&#10;        &quot;&quot;&quot;&#10;        print(f&quot;\nDESCRIPCION DEL PROBLEMA:&quot;)&#10;        print(f&quot;{puzzle_data['description']}\n&quot;)&#10;&#10;        # Mostrar simbolos&#10;        print(&quot;SIMBOLOS PROPOSICIONALES:&quot;)&#10;        self.symbols_dict = puzzle_data['symbols']&#10;        for symbol, meaning in self.symbols_dict.items():&#10;            print(f&quot;   {symbol}: {meaning}&quot;)&#10;&#10;        # Construir la base de conocimiento&#10;        print(&quot;\nPREMISAS (Base de Conocimiento):&quot;)&#10;        self.premises = puzzle_data['premises']&#10;        knowledge_sentences = []&#10;&#10;        for i, premise in enumerate(self.premises, 1):&#10;            sentence = premise['sentence']&#10;            description = premise['description']&#10;            knowledge_sentences.append(sentence)&#10;            print(f&quot;   {i}. {description}&quot;)&#10;            print(f&quot;      Formula: {sentence.formula()}&quot;)&#10;&#10;        # Combinar todas las premisas en una base de conocimiento&#10;        self.knowledge_base = And(*knowledge_sentences)&#10;&#10;        # Mostrar preguntas&#10;        print(&quot;\nPREGUNTAS A RESOLVER:&quot;)&#10;        self.queries = puzzle_data['queries']&#10;        for i, query in enumerate(self.queries, 1):&#10;            print(f&quot;   {i}. {query['question']}&quot;)&#10;&#10;        # Generar y mostrar tabla de verdad&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;TABLA DE VERDAD&quot;)&#10;        print(&quot;=&quot; * 80)&#10;&#10;        truth_table = TruthTable(self.knowledge_base, self.queries)&#10;        truth_table.generate()&#10;        truth_table.display()&#10;&#10;        # Resolver cada pregunta&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;RESPUESTAS&quot;)&#10;        print(&quot;=&quot; * 80)&#10;&#10;        for i, query_data in enumerate(self.queries, 1):&#10;            query = query_data['query']&#10;            question = query_data['question']&#10;&#10;            print(f&quot;\n{i}. {question}&quot;)&#10;            print(f&quot;   Formula: {query.formula()}&quot;)&#10;&#10;            # Verificar si la base de conocimiento implica la consulta&#10;            result = self.check_entailment(query)&#10;&#10;            if result == &quot;YES&quot;:&#10;                print(f&quot;   RESPUESTA: SI&quot;)&#10;                print(f&quot;   La base de conocimiento implica que {query.formula()} es VERDADERO&quot;)&#10;            elif result == &quot;NO&quot;:&#10;                print(f&quot;   RESPUESTA: NO&quot;)&#10;                print(f&quot;   La base de conocimiento implica que {query.formula()} es FALSO&quot;)&#10;            else:&#10;                print(f&quot;   RESPUESTA: NO SE PUEDE DETERMINAR&quot;)&#10;                print(f&quot;   La base de conocimiento no proporciona informacion suficiente&quot;)&#10;&#10;        # Visualizacion opcional&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        visualizer = Visualizer()&#10;        visualizer.create_summary(puzzle_data, self.queries, self)&#10;&#10;    def check_entailment(self, query):&#10;        &quot;&quot;&quot;&#10;        Verifica si la base de conocimiento implica la consulta.&#10;&#10;        Returns:&#10;            &quot;YES&quot; si KB implica query&#10;            &quot;NO&quot; si KB implica NOT query&#10;            &quot;UNKNOWN&quot; si no se puede determinar&#10;        &quot;&quot;&quot;&#10;        # Obtener todos los simbolos&#10;        symbols = list(self.knowledge_base.symbols().union(query.symbols()))&#10;&#10;        # Verificar si KB implica query&#10;        if model_check(self.knowledge_base, query):&#10;            return &quot;YES&quot;&#10;&#10;        # Verificar si KB implica NOT query&#10;        if model_check(self.knowledge_base, Not(query)):&#10;            return &quot;NO&quot;&#10;&#10;        return &quot;UNKNOWN&quot;" />
              <option name="updatedContent" value="from logic import *&#10;import itertools&#10;from truth_table import TruthTable&#10;from visualizer import Visualizer&#10;from matplotlib_visualizer import MatplotlibVisualizer&#10;from logic_simplifier import LogicSimplifier&#10;&#10;&#10;class LogicPuzzleSolver:&#10;    &quot;&quot;&quot;&#10;    Clase principal para resolver rompecabezas logicos usando&#10;    logica proposicional y tablas de verdad.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.knowledge_base = None&#10;        self.symbols_dict = {}&#10;        self.premises = []&#10;        self.queries = []&#10;        self.matplotlib_viz = MatplotlibVisualizer()&#10;        self.simplifier = LogicSimplifier()&#10;&#10;    def solve_puzzle(self, puzzle_data):&#10;        &quot;&quot;&quot;&#10;        Resuelve un rompecabezas logico completo.&#10;&#10;        Args:&#10;            puzzle_data: Diccionario con la estructura del rompecabezas&#10;        &quot;&quot;&quot;&#10;        print(f&quot;\nDESCRIPCION DEL PROBLEMA:&quot;)&#10;        print(f&quot;{puzzle_data['description']}\n&quot;)&#10;&#10;        # Mostrar simbolos&#10;        print(&quot;SIMBOLOS PROPOSICIONALES:&quot;)&#10;        self.symbols_dict = puzzle_data['symbols']&#10;        for symbol, meaning in self.symbols_dict.items():&#10;            print(f&quot;   {symbol}: {meaning}&quot;)&#10;&#10;        # Construir la base de conocimiento&#10;        print(&quot;\nPREMISAS (Base de Conocimiento):&quot;)&#10;        self.premises = puzzle_data['premises']&#10;        knowledge_sentences = []&#10;&#10;        for i, premise in enumerate(self.premises, 1):&#10;            sentence = premise['sentence']&#10;            description = premise['description']&#10;            knowledge_sentences.append(sentence)&#10;            print(f&quot;   {i}. {description}&quot;)&#10;            print(f&quot;      Formula: {sentence.formula()}&quot;)&#10;&#10;        # Combinar todas las premisas en una base de conocimiento&#10;        self.knowledge_base = And(*knowledge_sentences)&#10;&#10;        # Mostrar simplificación de la base de conocimiento&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;ANÁLISIS Y SIMPLIFICACIÓN (usando SymPy)&quot;)&#10;        print(&quot;=&quot; * 80)&#10;        self.simplifier.display_analysis(self.knowledge_base, &#10;                                         &quot;Base de Conocimiento Completa&quot;)&#10;&#10;        # Mostrar preguntas&#10;        print(&quot;\nPREGUNTAS A RESOLVER:&quot;)&#10;        self.queries = puzzle_data['queries']&#10;        for i, query in enumerate(self.queries, 1):&#10;            print(f&quot;   {i}. {query['question']}&quot;)&#10;&#10;        # Generar y mostrar tabla de verdad&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;TABLA DE VERDAD&quot;)&#10;        print(&quot;=&quot; * 80)&#10;&#10;        truth_table = TruthTable(self.knowledge_base, self.queries)&#10;        truth_table.generate()&#10;        truth_table.display()&#10;&#10;        # Resolver cada pregunta&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;RESPUESTAS&quot;)&#10;        print(&quot;=&quot; * 80)&#10;&#10;        for i, query_data in enumerate(self.queries, 1):&#10;            query = query_data['query']&#10;            question = query_data['question']&#10;&#10;            print(f&quot;\n{i}. {question}&quot;)&#10;            print(f&quot;   Formula: {query.formula()}&quot;)&#10;&#10;            # Verificar si la base de conocimiento implica la consulta&#10;            result = self.check_entailment(query)&#10;&#10;            if result == &quot;YES&quot;:&#10;                print(f&quot;   RESPUESTA: SI&quot;)&#10;                print(f&quot;   La base de conocimiento implica que {query.formula()} es VERDADERO&quot;)&#10;            elif result == &quot;NO&quot;:&#10;                print(f&quot;   RESPUESTA: NO&quot;)&#10;                print(f&quot;   La base de conocimiento implica que {query.formula()} es FALSO&quot;)&#10;            else:&#10;                print(f&quot;   RESPUESTA: NO SE PUEDE DETERMINAR&quot;)&#10;                print(f&quot;   La base de conocimiento no proporciona informacion suficiente&quot;)&#10;&#10;        # Visualizacion opcional&#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        visualizer = Visualizer()&#10;        visualizer.create_summary(puzzle_data, self.queries, self)&#10;&#10;    def check_entailment(self, query):&#10;        &quot;&quot;&quot;&#10;        Verifica si la base de conocimiento implica la consulta.&#10;&#10;        Returns:&#10;            &quot;YES&quot; si KB implica query&#10;            &quot;NO&quot; si KB implica NOT query&#10;            &quot;UNKNOWN&quot; si no se puede determinar&#10;        &quot;&quot;&quot;&#10;        # Obtener todos los simbolos&#10;        symbols = list(self.knowledge_base.symbols().union(query.symbols()))&#10;&#10;        # Verificar si KB implica query&#10;        if model_check(self.knowledge_base, query):&#10;            return &quot;YES&quot;&#10;&#10;        # Verificar si KB implica NOT query&#10;        if model_check(self.knowledge_base, Not(query)):&#10;            return &quot;NO&quot;&#10;&#10;        return &quot;UNKNOWN&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="from logic_solver import LogicPuzzleSolver&#10;from examples import get_unicorn_example, get_custom_example&#10;&#10;def main():&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;SOLUCIONADOR DE ROMPECABEZAS LOGICOS&quot;)&#10;    print(&quot;Usando Logica Proposicional y Tablas de Verdad&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    print()&#10;&#10;    # Crear el solucionador&#10;    solver = LogicPuzzleSolver()&#10;&#10;    # Ejemplo del unicornio&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;EJEMPLO 1: EL UNICORNIO&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    unicorn_puzzle = get_unicorn_example()&#10;    solver.solve_puzzle(unicorn_puzzle)&#10;&#10;    # Puedes agregar mas ejemplos aqui&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;Deseas resolver otro rompecabezas? (s/n)&quot;)&#10;    respuesta = input().lower()&#10;&#10;    if respuesta == 's':&#10;        print(&quot;\nFuncionalidad para agregar rompecabezas personalizados...&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
              <option name="updatedContent" value="from logic_solver import LogicPuzzleSolver&#10;from examples import get_unicorn_example, get_custom_example&#10;from input_handler import InputHandler&#10;&#10;&#10;def show_menu():&#10;    &quot;&quot;&quot;Muestra el menú principal.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;MENÚ PRINCIPAL&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;\n1. Resolver ejemplo del unicornio (predefinido)&quot;)&#10;    print(&quot;2. Crear y resolver rompecabezas personalizado&quot;)&#10;    print(&quot;3. Salir&quot;)&#10;    print(&quot;\nSelecciona una opción: &quot;, end=&quot;&quot;)&#10;&#10;&#10;def main():&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;SOLUCIONADOR DE ROMPECABEZAS LÓGICOS&quot;)&#10;    print(&quot;Usando Lógica Proposicional y Tablas de Verdad&quot;)&#10;    print(&quot;Con visualizaciones avanzadas (Matplotlib, Pandas, NumPy, SymPy)&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;    # Crear el solucionador&#10;    solver = LogicPuzzleSolver()&#10;&#10;    while True:&#10;        show_menu()&#10;        opcion = input().strip()&#10;&#10;        if opcion == '1':&#10;            # Ejemplo del unicornio&#10;            print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;            print(&quot;EJEMPLO: EL UNICORNIO MÍTICO&quot;)&#10;            print(&quot;=&quot; * 80)&#10;            unicorn_puzzle = get_unicorn_example()&#10;            solver.solve_puzzle(unicorn_puzzle)&#10;&#10;        elif opcion == '2':&#10;            # Rompecabezas personalizado&#10;            handler = InputHandler()&#10;            custom_puzzle = handler.create_custom_puzzle()&#10;            &#10;            if custom_puzzle:&#10;                print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;                print(&quot;RESOLVIENDO TU ROMPECABEZAS PERSONALIZADO&quot;)&#10;                print(&quot;=&quot; * 80)&#10;                solver.solve_puzzle(custom_puzzle)&#10;&#10;        elif opcion == '3':&#10;            print(&quot;\n¡Hasta luego! Gracias por usar el solucionador de rompecabezas lógicos.&quot;)&#10;            break&#10;&#10;        else:&#10;            print(&quot;\n⚠ Opción no válida. Por favor, selecciona 1, 2 o 3.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/truth_table.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/truth_table.py" />
              <option name="originalContent" value="# truth_table.py - Generador de tablas de verdad&#10;import itertools&#10;from tabulate import tabulate&#10;import pandas as pd&#10;import numpy as np&#10;import itertools&#10;&#10;&#10;class TruthTable:&#10;    &quot;&quot;&quot;&#10;    Clase para generar y mostrar tablas de verdad.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, knowledge_base, queries):&#10;        self.knowledge_base = knowledge_base&#10;        self.queries = queries&#10;        self.symbols = sorted(list(knowledge_base.symbols()))&#10;        self.table_data = []&#10;        self.headers = []&#10;        self.df = None  # DataFrame de pandas&#10;&#10;    def generate(self):&#10;        &quot;&quot;&quot;Genera la tabla de verdad completa.&quot;&quot;&quot;&#10;        # Crear encabezados&#10;        self.headers = self.symbols.copy()&#10;        self.headers.append(&quot;KB&quot;)&#10;        for query_data in self.queries:&#10;            query_symbol = query_data.get('symbol', 'Q')&#10;            self.headers.append(query_symbol)&#10;&#10;        # Generar todas las combinaciones posibles usando numpy para eficiencia&#10;        n_symbols = len(self.symbols)&#10;&#10;        for values in itertools.product([False, True], repeat=n_symbols):&#10;            # Crear modelo&#10;            model = dict(zip(self.symbols, values))&#10;&#10;            # Evaluar base de conocimiento&#10;            kb_value = self.knowledge_base.evaluate(model)&#10;&#10;            # Crear fila&#10;            row = [self._bool_to_int(v) for v in values]&#10;            row.append(self._bool_to_int(kb_value))&#10;&#10;            # Evaluar cada consulta&#10;            for query_data in self.queries:&#10;                query = query_data['query']&#10;                query_value = query.evaluate(model)&#10;                row.append(self._bool_to_int(query_value))&#10;&#10;            self.table_data.append(row)&#10;&#10;        # Crear DataFrame de pandas&#10;        self.df = pd.DataFrame(self.table_data, columns=self.headers)&#10;&#10;        # Convertir a tipo int para mejor visualización&#10;        self.df = self.df.astype(int)&#10;&#10;    def display(self):&#10;        &quot;&quot;&quot;Muestra la tabla de verdad formateada.&quot;&quot;&quot;&#10;        if not self.table_data:&#10;            print(&quot;No hay datos en la tabla de verdad&quot;)&#10;            return&#10;&#10;        # Usar tabulate para una mejor visualizacion&#10;        print(tabulate(self.table_data, headers=self.headers,&#10;                       tablefmt=&quot;grid&quot;, stralign=&quot;center&quot;))&#10;&#10;        # Mostrar leyenda&#10;        print(&quot;\nLeyenda:&quot;)&#10;        print(&quot;   0 = Falso, 1 = Verdadero&quot;)&#10;        print(&quot;   KB = Base de Conocimiento (todas las premisas)&quot;)&#10;        for i, query_data in enumerate(self.queries):&#10;            symbol = query_data.get('symbol', f'Q{i + 1}')&#10;            question = query_data['question']&#10;            print(f&quot;   {symbol} = {question}&quot;)&#10;&#10;    def _bool_to_int(self, value):&#10;        &quot;&quot;&quot;Convierte booleano a 0 o 1.&quot;&quot;&quot;&#10;        return 1 if value else 0&#10;&#10;    def get_valid_models(self):&#10;        &quot;&quot;&quot;Retorna solo los modelos donde KB es verdadero.&quot;&quot;&quot;&#10;        valid_models = []&#10;        for row in self.table_data:&#10;            if row[len(self.symbols)] == 1:  # KB es verdadero&#10;                valid_models.append(row)&#10;        return valid_models" />
              <option name="updatedContent" value="# truth_table.py - Generador de tablas de verdad&#10;import itertools&#10;from tabulate import tabulate&#10;import pandas as pd&#10;import numpy as np&#10;import itertools&#10;&#10;&#10;class TruthTable:&#10;    &quot;&quot;&quot;&#10;    Clase para generar y mostrar tablas de verdad.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, knowledge_base, queries):&#10;        self.knowledge_base = knowledge_base&#10;        self.queries = queries&#10;        self.symbols = sorted(list(knowledge_base.symbols()))&#10;        self.table_data = []&#10;        self.headers = []&#10;        self.df = None  # DataFrame de pandas&#10;&#10;    def generate(self):&#10;        &quot;&quot;&quot;Genera la tabla de verdad completa.&quot;&quot;&quot;&#10;        # Crear encabezados&#10;        self.headers = self.symbols.copy()&#10;        self.headers.append(&quot;KB&quot;)&#10;        for query_data in self.queries:&#10;            query_symbol = query_data.get('symbol', 'Q')&#10;            self.headers.append(query_symbol)&#10;&#10;        # Generar todas las combinaciones posibles usando numpy para eficiencia&#10;        n_symbols = len(self.symbols)&#10;&#10;        for values in itertools.product([False, True], repeat=n_symbols):&#10;            # Crear modelo&#10;            model = dict(zip(self.symbols, values))&#10;&#10;            # Evaluar base de conocimiento&#10;            kb_value = self.knowledge_base.evaluate(model)&#10;&#10;            # Crear fila&#10;            row = [self._bool_to_int(v) for v in values]&#10;            row.append(self._bool_to_int(kb_value))&#10;&#10;            # Evaluar cada consulta&#10;            for query_data in self.queries:&#10;                query = query_data['query']&#10;                query_value = query.evaluate(model)&#10;                row.append(self._bool_to_int(query_value))&#10;&#10;            self.table_data.append(row)&#10;&#10;        # Crear DataFrame de pandas&#10;        self.df = pd.DataFrame(self.table_data, columns=self.headers)&#10;&#10;        # Convertir a tipo int para mejor visualización&#10;        self.df = self.df.astype(int)&#10;&#10;    def display(self):&#10;        &quot;&quot;&quot;Muestra la tabla de verdad formateada.&quot;&quot;&quot;&#10;        if not self.table_data:&#10;            print(&quot;No hay datos en la tabla de verdad&quot;)&#10;            return&#10;&#10;        # Usar tabulate para una mejor visualizacion&#10;        print(tabulate(self.table_data, headers=self.headers,&#10;                       tablefmt=&quot;grid&quot;, stralign=&quot;center&quot;))&#10;&#10;        # Mostrar leyenda&#10;        print(&quot;\nLeyenda:&quot;)&#10;        print(&quot;   0 = Falso, 1 = Verdadero&quot;)&#10;        print(&quot;   KB = Base de Conocimiento (todas las premisas)&quot;)&#10;        for i, query_data in enumerate(self.queries):&#10;            symbol = query_data.get('symbol', f'Q{i + 1}')&#10;            question = query_data['question']&#10;            print(f&quot;   {symbol} = {question}&quot;)&#10;&#10;    def _bool_to_int(self, value):&#10;        &quot;&quot;&quot;Convierte booleano a 0 o 1.&quot;&quot;&quot;&#10;        return 1 if value else 0&#10;&#10;    def get_valid_models(self):&#10;        &quot;&quot;&quot;Retorna solo los modelos donde KB es verdadero.&quot;&quot;&quot;&#10;        valid_models = []&#10;        for row in self.table_data:&#10;            if row[len(self.symbols)] == 1:  # KB es verdadero&#10;                valid_models.append(row)&#10;        return valid_models&#10;    &#10;    def get_dataframe(self):&#10;        &quot;&quot;&quot;Retorna el DataFrame de pandas con la tabla de verdad.&quot;&quot;&quot;&#10;        return self.df&#10;    &#10;    def get_valid_models_df(self):&#10;        &quot;&quot;&quot;Retorna un DataFrame con solo los modelos válidos.&quot;&quot;&quot;&#10;        if self.df is None:&#10;            return None&#10;        kb_column = 'KB'&#10;        return self.df[self.df[kb_column] == 1]&#10;    &#10;    def export_to_csv(self, filename=&quot;tabla_verdad.csv&quot;):&#10;        &quot;&quot;&quot;Exporta la tabla de verdad a un archivo CSV.&quot;&quot;&quot;&#10;        if self.df is not None:&#10;            self.df.to_csv(filename, index=False)&#10;            print(f&quot;\n✓ Tabla exportada a: {filename}&quot;)&#10;        else:&#10;            print(&quot;⚠ No hay tabla de verdad generada.&quot;)&#10;    &#10;    def get_symbol_statistics(self):&#10;        &quot;&quot;&quot;&#10;        Calcula estadísticas sobre los símbolos en modelos válidos.&#10;        &#10;        Returns:&#10;            Diccionario con frecuencias de cada símbolo&#10;        &quot;&quot;&quot;&#10;        if self.df is None:&#10;            return {}&#10;        &#10;        valid_df = self.get_valid_models_df()&#10;        if valid_df.empty:&#10;            return {}&#10;        &#10;        stats = {}&#10;        for symbol in self.symbols:&#10;            stats[symbol] = {&#10;                'true': int(valid_df[symbol].sum()),&#10;                'false': int(len(valid_df) - valid_df[symbol].sum()),&#10;                'total': len(valid_df)&#10;            }&#10;        &#10;        return stats&#10;    &#10;    def display_statistics(self):&#10;        &quot;&quot;&quot;Muestra estadísticas sobre la tabla de verdad.&quot;&quot;&quot;&#10;        if self.df is None:&#10;            print(&quot;No hay tabla de verdad generada.&quot;)&#10;            return&#10;        &#10;        print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;        print(&quot;ESTADÍSTICAS DE LA TABLA DE VERDAD&quot;)&#10;        print(&quot;=&quot; * 80)&#10;        &#10;        total_models = len(self.df)&#10;        valid_models = len(self.get_valid_models_df())&#10;        &#10;        print(f&quot;\nTotal de modelos posibles: {total_models}&quot;)&#10;        print(f&quot;Modelos que satisfacen KB: {valid_models}&quot;)&#10;        print(f&quot;Porcentaje de validez: {(valid_models/total_models)*100:.2f}%&quot;)&#10;        &#10;        # Estadísticas por símbolo&#10;        stats = self.get_symbol_statistics()&#10;        if stats:&#10;            print(&quot;\nFrecuencia de símbolos en modelos válidos:&quot;)&#10;            for symbol, data in stats.items():&#10;                print(f&quot;  {symbol}:&quot;)&#10;                print(f&quot;    Verdadero: {data['true']} ({data['true']/data['total']*100:.1f}%)&quot;)&#10;                print(f&quot;    Falso: {data['false']} ({data['false']/data['total']*100:.1f}%)&quot;)&#10;        &#10;        print(&quot;=&quot; * 80)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>